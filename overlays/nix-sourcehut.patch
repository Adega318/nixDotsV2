diff --git a/Makefile.config.in b/Makefile.config.in
index c8c4446b4..e7a81a6f2 100644
--- a/Makefile.config.in
+++ b/Makefile.config.in
@@ -18,6 +18,7 @@ LIBBROTLI_LIBS = @LIBBROTLI_LIBS@
 LIBCURL_LIBS = @LIBCURL_LIBS@
 OPENSSL_LIBS = @OPENSSL_LIBS@
 LIBSECCOMP_LIBS = @LIBSECCOMP_LIBS@
+LIBPUGIXML_LIBS = @LIBPUGIXML_LIBS@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 SHELL = @bash@
diff --git a/configure.ac b/configure.ac
index 65478ecc5..425d5b3ba 100644
--- a/configure.ac
+++ b/configure.ac
@@ -202,6 +202,8 @@ if test "$machine_name" = "x86_64"; then
 fi
 AC_SUBST(HAVE_LIBCPUID, [$have_libcpuid])
 
+# Look for pugixml library.
+PKG_CHECK_MODULES([LIBPUGIXML], [pugixml >= 1.11], [CXXFLAGS="$LIBPUGIXML_CFLAGS $CXXFLAGS"])
 
 # Look for libseccomp, required for Linux sandboxing.
 case "$host_os" in
diff --git a/doc/manual/src/installation/prerequisites-source.md b/doc/manual/src/installation/prerequisites-source.md
index 40cb79627..7826523e4 100644
--- a/doc/manual/src/installation/prerequisites-source.md
+++ b/doc/manual/src/installation/prerequisites-source.md
@@ -26,6 +26,10 @@
     available for download from the official repository
     <https://github.com/google/brotli>.
 
+  - The `libpugixml` library to deserialize XML. If your distribution
+    does not provide it, you can get it from
+    <https://github.com/zeux/pugixml>.
+
   - cURL and its library. If your distribution does not provide it, you
     can get it from <https://curl.haxx.se/>.
 
diff --git a/flake.nix b/flake.nix
index 5f77e42d1..301982154 100644
--- a/flake.nix
+++ b/flake.nix
@@ -91,6 +91,7 @@
             boost
             lowdown
             gmock
+            pugixml
           ]
           ++ lib.optionals stdenv.isLinux [libseccomp]
           ++ lib.optional (stdenv.isLinux || stdenv.isDarwin) libsodium
diff --git a/src/libfetchers/github.cc b/src/libfetchers/github.cc
index ffc44e9e2..5fa8e2a2c 100644
--- a/src/libfetchers/github.cc
+++ b/src/libfetchers/github.cc
@@ -8,6 +8,7 @@
 
 #include <optional>
 #include <nlohmann/json.hpp>
+#include <pugixml.hpp>
 
 namespace nix::fetchers {
 
@@ -17,7 +18,7 @@ struct DownloadUrl
     Headers headers;
 };
 
-// A github or gitlab host
+// A github, gitlab, or sourcehut host
 const static std::string hostRegexS = "[a-zA-Z0-9.]*"; // FIXME: check
 std::regex hostRegex(hostRegexS, std::regex::ECMAScript);
 
@@ -348,7 +349,71 @@ struct GitLabInputScheme : GitArchiveInputScheme
     }
 };
 
+struct SourceHutInputScheme : GitArchiveInputScheme
+{
+    std::string type() override { return "sourcehut"; }
+
+    std::optional<std::pair<std::string, std::string>> accessHeaderFromToken(const std::string & token) const override
+    {
+        // SourceHut supports both PAT and OAuth2. See
+        // https://man.sr.ht/meta.sr.ht/oauth.md
+        return std::pair<std::string, std::string>("Authorization", fmt("Bearer %s", token));
+        // Note: This currently serves no purpose, as this kind of authorization
+        // does not allow for downloading tarballs on sourcehut private repos.
+        // Once it is implemented, however, should work as expected.
+    }
+
+    Hash getRevFromRef(nix::ref<Store> store, const Input & input) const override
+    {
+        auto ref = *input.getRef();
+        if (ref == "HEAD") {
+            ref = "";
+        } else {
+            ref = fmt("/%s", ref);
+        }
+        auto host = maybeGetStrAttr(input.attrs, "host").value_or("git.sr.ht");
+        auto url = fmt("https://%s/%s/%s/log%s/rss.xml",
+            host, getStrAttr(input.attrs, "owner"), getStrAttr(input.attrs, "repo"), ref);
+
+        Headers headers = makeHeadersWithAuthTokens(host);
+
+        auto xmlFile = store->toRealPath(
+                downloadFile(store, url, "source", false, headers).storePath);
+
+        pugi::xml_document doc;
+        doc.load_file(xmlFile.c_str());
+
+        std::string commitUrl = doc.child("rss").child("channel").child("item").child_value("link");
+        auto id = commitUrl.substr(commitUrl.find("commit/")+7, commitUrl.length()-1);
+
+        auto rev = Hash::parseAny(id, htSHA1);
+        debug("HEAD revision for '%s' is %s", url, rev.gitRev());
+        return rev;
+    }
+
+    DownloadUrl getDownloadUrl(const Input & input) const override
+    {
+        auto host = maybeGetStrAttr(input.attrs, "host").value_or("git.sr.ht");
+        auto url = fmt("https://%s/%s/%s/archive/%s.tar.gz",
+            host, getStrAttr(input.attrs, "owner"), getStrAttr(input.attrs, "repo"),
+            input.getRev()->to_string(Base16, false));
+
+        Headers headers = makeHeadersWithAuthTokens(host);
+        return DownloadUrl { url, headers };
+    }
+
+    void clone(const Input & input, const Path & destDir) override
+    {
+        auto host = maybeGetStrAttr(input.attrs, "host").value_or("git.sr.ht");
+        Input::fromURL(fmt("git+https://%s/%s/%s",
+                host, getStrAttr(input.attrs, "owner"), getStrAttr(input.attrs, "repo")))
+            .applyOverrides(input.getRef(), input.getRev())
+            .clone(destDir);
+    }
+};
+
 static auto rGitHubInputScheme = OnStartup([] { registerInputScheme(std::make_unique<GitHubInputScheme>()); });
 static auto rGitLabInputScheme = OnStartup([] { registerInputScheme(std::make_unique<GitLabInputScheme>()); });
+static auto rSourceHutInputScheme = OnStartup([] { registerInputScheme(std::make_unique<SourceHutInputScheme>()); });
 
 }
diff --git a/src/libfetchers/local.mk b/src/libfetchers/local.mk
index 2e8869d83..f91b8f1bb 100644
--- a/src/libfetchers/local.mk
+++ b/src/libfetchers/local.mk
@@ -8,6 +8,6 @@ libfetchers_SOURCES := $(wildcard $(d)/*.cc)
 
 libfetchers_CXXFLAGS += -I src/libutil -I src/libstore
 
-libfetchers_LDFLAGS += -pthread
+libfetchers_LDFLAGS += -pthread $(LIBPUGIXML_LIBS)
 
 libfetchers_LIBS = libutil libstore
diff --git a/src/libstore/globals.hh b/src/libstore/globals.hh
index 8784d5faf..142be99d0 100644
--- a/src/libstore/globals.hh
+++ b/src/libstore/globals.hh
@@ -900,10 +900,14 @@ public:
             `type` is either `OAuth2` or `PAT` to indicate which type
             of token is being specified.
 
+          * SourceHut: the token value is the string obtained either
+            as the Personal Access Token (https://meta.sr.ht/oauth2/personal-token),
+            or through OAuth2.
+
           Example `~/.config/nix/nix.conf`:
 
           ```
-          access-tokens = github.com=23ac...b289 gitlab.mycompany.com=PAT:A123Bp_Cd..EfG gitlab.com=OAuth2:1jklw3jk
+          access-tokens = github.com=23ac...b289 gitlab.mycompany.com=PAT:A123Bp_Cd..EfG gitlab.com=OAuth2:1jklw3jk git.sr.ht=ACiMP...KI1c
           ```
 
           Example `~/code/flake.nix`:
